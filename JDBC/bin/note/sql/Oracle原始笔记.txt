软件的构成？
1、前端 HTML、CSS、JS、JQuery
2、后台 java
3、数据库 Oracle Mysql(甲骨文)

1.安装Oracle

  常用用户：
    sys：超级用户  具有最高权限  具有sysdba角色 （数据库管理员）
         有创建数据库的权限 
    system：管理操作员  权限仅次于超级管理员   

    scott:普通用户 一般用于练习    scott -- tiger
	解锁用户：alter user scott account unlock
	设置密码：alter user scott identified by tiger
   
2.登录方式
  1）sqlplus 回车
     输入用户名
     输入密码

  2）sqlplus/nolog
     conn scott/tiger

3.  DB：DataBase 按照数据结构来管理数据的仓库
        关系型数据库
        以二维表形式存储数据(表的列：字段名  表的行：数据)
 

    DBMS：数据库管理系统
          mysql、oracle、SqlServer
4.常用命令
    sqlplus  打开数据库
    conn  用户名/密码    连接数据库
    show user; 显示当前用户
    exit;  断开连接
    quit;  断开连接
5.SQL:结构化查询语言
  SQL的分类：*****
	  DDL 数据定义语言  用于操作数据对象（表 视图 序列 索引）
	  DML 数据操作语言  用于增删改表中的数据(通常伴随事务)
	  TCL 事务控制语言  用于数据的提交和撤销
	  DQL 数据查询语言  用于查询数据记录
	  DCL 数据控制语言  用于执行权限分配
	  
	  DDL：数据定义语言
		   ---用于操作数据库对象（表 视图 序列 索引）
		   CREATE：用来创建表或其他对象
		   ALTER：修改表或其他对象的结构
		   DROP：删除表或其他对象的结构
		   TRUNCATE：清空表(删除表中数据，保留表结构) 
	  DML：数据操作语言
		   ---用于增删改表中的数据(通常伴随事务)
		   INSERT INTO：将数据插入到表中
		   DELETE：删除表中数据 ---- WHERE
		   UPDATE 表名 SET：更新表中数据 --- WHERE
		   
      TCL：事务控制语言
		   COMMIT：提交--保存
           ROLLBACK：回滚---后退
   
      DQL：数据查询语言
           SELECT 查询*****

      DCL：数据控制语言
           用来执行权限分配 GRANT REVOKE
6.DDL 数据定义语言
	1、创建表
		查看用户定义的表：
		SELECT table_name FROM user_tables;
		CREATE TABLE 表名 (
			列名(字段名)  数据类型 [默认值  约束],
			列名(字段名)  数据类型 [默认值  约束],
			列名(字段名)  数据类型 [默认值  约束],
			列名(字段名)  数据类型 [默认值  约束]
		);
		CREATE TABLE users(
			id number(10) primary key,
			name varchar2(20) not null unique,
			salary number(10,2),
			create_time date default sysdate
		);
		id(主键) 特点：该列在整张表中每一行所保存的值都不相同，且必须有值（非空且唯一）PRIMARY KEY
		命名规则：
			表名和列名：
			1）必须以字母开头
			2）必须在1-30个字符之间
			3）必须只能包含A-Z,a-z,0-9,_,$,和#
			4）必须不能和用户定义的其他对象重名
			5）必须不能是Oracle的保留字
		数据类型:
			1）NUMBER:数值类型
			   NUMBER(X):x代表位数  
						 NUMBER(3)  最多能存放3位数
			   NUMBER(X,Y):x表示共几位  y表示其中有几位是小数
						   NUMBER(6,2) 8888.88
			2）CHAR:定长字符串
			   CHAR(X):X表示共占多少字节   最多放2000字节
			3）VARCHAR2:变长字符串
			   VARCHAR2(X):X表示共占多少字节(根据其中保存的数据长度，占用的空间是变化的)  最多4000字节
			4）DATE 时间日期
			SELECT SYSDATE FROM DUAL
		    伪表：dual确实是一张表，是一张只有一个字段，一行记录的表，习惯上我们称之为伪表，因为它不存储
			具体的数据
	2、删除表：
		DROP TABLE users;
	3、ALTER：修改表
		修改表名：
		RENAME 原表名 TO 新表名
		修改表结构：
			向表中添加字段：
				ALTER TABLE 表名 ADD(字段名 数据类型[默认值 约束])
	            列只能添加在最后，不能插入到现有的列中
	        删除表中已有字段：
				ALTER TABLE 表名 DROP(字段名)
			修改表中已有字段的格式：
				ALTER TABLE 表名 MODIFY(字段名 数据类型[默认值 约束])
7、DML 数据操作语言
	1、向表中添加数据
		全字段插入数据：
		INSERT INTO 表名 VALUES(1,'张三',8000,sysdate,'程序员');
		注意：values中的数据顺序要和定义字段时一致
	    部分字段插入数据
		INSERT INTO 表名(想要插入数据的字段) VALUES(与字段顺序相对应的数据)
	2、修改表中已有数据
		在修改表中数据时，通常添加where子句来限定要修改的记录，这样就只能修改满足where条件的记录，
		否则是全表修改
		UPDATE 表名 SET 字段名=数据,字段名=数据 WHERE 字段名=数据
	3、删除表中数据
		通常与where子句连用，否则的话是删除所有数据
	    DELETE FROM 表名 WHERE 字段名=数据
		在DDL语句中的TRUNCATE语句，同样有删除表数据的作用
		和delete的区别：
		--delete可以有条件删除，truncate将表数据全部删除
		--delete是DML，可以回退，truncate是DDL语句，立即生效，无法回退
		--如果是删除全部表记录，且数据量较大，delete语句效率比truncate语句低
		删除全部记录：
		delete from users;
	    或者
		truncate table users;
8.TCL 事务控制语言
	commit 提交
	显示：语句 按钮
	隐式：正常关闭数据库工具
	rollback 回滚---后退
	事务的四个特性：*****
		1.原子性：事务包含的所有操作要么全部成功，要么全部失败回滚;成功必须要完全应用到数据库，失败则不能对数据库
				  产生影响；
		2.一致性：事务执行前和执行后必须处于一致性状态，
		3.隔离性：当多个用户并发访问数据库时，数据库为每一个用户开启的事务，不被其他事务的操作所干扰，多个并
		          发事务之间要相互隔离；
		4.持久性：一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的
9.DQL 数据查询语言
	基本查询语句由SELECT子句和FROM子句组成
	SELECT：指定要显示的字段名称
	FROM：指定数据来源
	1）查询所有
    SELECT * FROM 表名;
	2）查询部分数据信息
	SELECT 字段名称1,字段名称2 FROM 表名 WHERE 限定条件;
	注意：SELECT 可以显示字段、表达式、函数
	<>是不等于 
	若函数名称较长，不利于查询结果的列名显示，则可以给查询结果的列使用列别名
	别名不能以数字开头，若以数字开头别名需要用""括上，同样不能以符号开头
		
10、常用函数
		1）字符串函数
			CONCAT(c1,c2)连接字符串，将c1，c2两个字段拼接显示
			||连接字符串符号（多个字符串连接，用||更直观）
			SELECT ename || ':'|| sal as "姓名:工资" from EMP
			
			LENGTH(字段名)显示字符串长度
			SELECT length(ename) from emp
			
			UPPER(字段名)转大写
			LOWER(字段名)转小写
			INITCAP(字段名)首字母大写
			
			TRIM() 去除字符串前后指定内容
			select trim('E' from 'EEEEEHELLO WORLDE') from dual
			
			去除员工表中名字的首字母A
			select ename,trim('A' FROM ename) from emp
			
			LTRIM('字符串','')去除字符串左侧指定内容
			RTRIM('字符串','')去除字符串右侧指定内容
			
			LPAD(ch1,m,ch2)
			RPAD(ch1,m,ch2)
			补位函数
			ch1要查询显示的内容 m指定位数
			ch2数据位数不足时由什么进行补位
			在emp表中使用左补位，将sql用0补齐6位
			select ename,rpad(sal,6,'$') from emp
			SUBSTR(ch,m,n)：截取字符串--从1开始
			截取ch这个字符串，从m开始截取，共截取n个
			若m为负数，则是从后向前进行下标查询从而进行截取
			INSTR(ch1,ch2,m,n)：查找ch1中ch2出现的位置，m代表从哪个位置开始检索，n代表第几次出现
			不指定m和n，默认值都是1
		2）数字函数
			ROUND(n,m)：用于四舍五入
			参数中的n可以是任何数字，指要被处理的数字
			m必须是整数，m取正数则四舍五入到小数点后第m位
			m取0则四舍五入到整数位
			m取负数，则四舍五入到小数点前m位
			m缺省，默认值是0
			TRUNC(n,m)：截取数字，没有四舍五入
			select trunc(45.678,2),trunc(45.678,0),trunc(45.678,-1) from dual
			MOD(m,n)：返回m除以n后的余数，n为0则直接返回M  
			薪水值按1000取余数
			select ename,sal,mod(sal,1000) from emp
			CEIL(n)：向上取整 大于该数的最小整数
			FLOOR(n)：向下取整 小于该数的最大整数
		3）日期函数
			sysdate：返回当前的系统时间，精确到秒 select sysdate from dual
			systimestamp：返回当前系统日期和时间，精确到毫秒（时间戳）
			1）TO_DATE()：相当于是SimpleDateFormat的parse()方法
			作用：将给定的字符串按照给定的日期格式转换为Date
			select to_date('2018-12-01 11:30','YYYY-MM-DD HH24:MI:SS') from dual
            2）TO_CHAR()：用于将DATE按照给定的日期格式转换为字符串
			select ename,to_char(hiredate,'YYYY"年"MM"月"DD"日"') from emp
			日期常用函数：
			1）LAST_DAY(date)：返回指定日期所在月的最后一天
			select last_day(sysdate) from dual
			2）ADD_MONTHS(date,i)：返回日期date加上i个月后的日期值，若果i是负数，则获得的是减去i个月后的
			日期值
			查询员工入职20周年纪念日
			select ename,add_months(hiredate,20*12) "20周年" from emp
			3）MONTHS_BETWEEN(date1,date2)：计算两个日期之间相差多少个月
			实际运算的是date1-date2，如果date2时间比date1时间晚，会得到负值，除非两个日期间隔是整数月，
			否则会得到带小数位的结果
			计算员工入职多少个月
			select ename,trunc(months_between(sysdate,hiredate)) from emp
			date日期类型在数据库中可以进行减法操作，结果是相差的天数
			select ename,sysdate-hiredate from emp
			4）LEAST(date1,date2)：显示两个时间中的最小值
			   GREATEST(date1,date2)：显示两个时间中的最大值
			   参数类型必须一致
			   select LEAST(sysdate,to_date('2018-12-1','YYYY-MM-DD')) from dual
			5）EXTRACT(date from datetime)：从参数datetime中提取参数date指定的数据，比如提取年、月、日
			select extract(day from sysdate) from dual
			查询1980年入职的员工有哪些
			select ename from emp where extract(year from hiredate) = 1980
		4）空值函数
			null的含义：
			有时表中的某些字段值，数据未知或暂时不存在，取值null
			任何数据类型均可取值null
			null条件查询：
			null不等于任何值
			判断一个字段的值是否为null，要使用is null或is not null
			select * from emp where comm is null
			非空约束：
				非空（not null）约束用于确保字段值不为空
			1）NVL(arg1,arg2)：将null转变为非null值
			如果arg1为null，返回arg2，否则返回arg1；arg1和arg2可以是任何数据类型，但两个参数的数据类型必
			须是一致的
			计算员工月收入
			select ename,sal,comm,sal+nvl(comm,0) from emp
			2）NVL2(arg,res1,res2)：如果arg为null，则返回res2;arg不为null，则返回res1
			select ename,sal,comm,nvl2(comm,sal+comm,sal) from emp
11、基本查询语句：
	1）from子句：
	select * from 表名
	select--用于指定要查询的列
	from--指定要从哪个表中查询
	2）where子句：
	在select语句中，可以在where子句中使用比较操作符限制查询结果
	查询部门10下的员工信息
	select * from emp where deptno=10
	查询员工表中职位是'SALESMAN'的员工信息
	select * from emp where job='SALESMAN'   --oracle中字符串区分大小写
12、查询条件
	1）使用>,<,>=,<=,!=,<>,=
	查询职员表中薪水低于2000的职员信息
	select ename,sal from emp where sal<2000
	查询职员表中不属于部门10的员工信息
	select ename,sal,job from emp where deptno <> 10
	查询职员表中在1981年1月1号以后入职的职员信息
	2）使用AND,OR关键字
	AND 并且  
	OR 或者  
	查询薪水大于1000并且职位是‘CLERK’的职员信息
	select ename,sal,job from emp where sal>1000 and job='CLERK'
	查询薪水大于1000或者职位是‘CLERK’的职员信息
	select ename,sal,job from emp where sal>1000 or job='CLERK'
	注意：AND优先级高于OR，可以使用()来提升优先级顺序
	select ename,sal,deptno from emp where deptno=20 or deptno=30 and sal>800
	3）模糊查询*****
	LIKE可以模糊匹配字符串
	select ename,job from emp where ename like 'A%'
	_:任意一个字符
	%:任意多个字符
	4）使用IN和NOT IN
	IN(list)：取出符合列表范围中的数据
	NOT IN(list)：取出不符合此列表中的数据记录
	查询职位是MANAGER或者CLERK的员工信息
	select * from emp where job in('MANAGER','CLERK')
	查询不是部门10或20的员工
	5）BETWEEN...AND...
	用来查询符合某个值域范围条件的数据（闭区间）
	等价于>= AND <=的效果
	查询薪水在1500-3000之间的职员信息
	select * from emp where sal between 1500 and 3000
	6）使用ANY和ALL条件
	ALL和ANY不能单独使用，需要配合单行比较操作符>,>=,<,<=一起使用
	>ANY：大于最小
	<ANY：小于最大
	>ALL：大于最大
	<ALL：小于最小
	查询员工表中工资比MANAGER工资高的员工信息
	select * from emp where sal>ANY(select sal from emp where job='MANAGER')
	7）distinct过滤重复数据
	查询员工的部门编号
	select distinct deptno from emp
	查询每个部门的职位
    select distinct deptno,job from emp
13、运算符优先级
	1）()
	2）算术运算符：* / + -
	3）连接符：||
	4）比较运算符：= > >= < <= <> is null,like,between...and...,in
	5）逻辑运算符：not and or
	BETWEEN...AND与AND的区别？
	1、BETWEEN...AND：只能用来比较一个字段值 
	2、AND：可以用来比较不同的字段
14、ORDER BY 排序
	对结果集的排序，必须出现在select的最后一个子句
	可以对结果集按照指定字段进行升序ASC或降序DESC
	select ename,sal from emp order by sal asc
	注意：排序的字段中若包含NULL，则NULL被看做最大值
	select * from emp where deptno=10 order by mgr desc
	多个列排序：
		当以多列最为排序标准时，首先按照第一列进行排序，如果第一列数据相同，再以第二列排序，以此类推
		多列排序不管正序还是倒序，每个列需要单独设置排序方式
		对员工表中的职员排序，先按照部门编号正序排列，再按照薪水降序排列
		select ename,deptno,sal from emp order by deptno asc,sal desc
15、聚合函数(多行函数、分组函数)
	1）MAX和MIN：用来取得列或表达式的最大、最小值
	可以用来统计任何数据类型，包括数字、字符和日期
	获取机构下的最高薪水和最低薪水，参数是数字
	select max(sal),min(sal) from emp
	最早和最晚的入职时间，参数是日期
	select max(hiredate),min(hiredate)  from emp
	2）AVG和SUM：用来统计列或表达式的平均值、和
	只能操作数字类型，忽略NULL值
	获取机构下全部职员的平均薪水和薪水总和
	select AVG(sal),SUM(sal) from emp
	3）COUNT：用来计算表中的记录条数，忽略NULL值
	获取职员表中一共有多少名职员记录
	select count(*) from emp
	获得职员表中有多少人是有奖金的
	select count(comm) from emp
	COUNT和SUM的区别？
	COUNT是统计记录数，SUM是统计记录中值的总和，注意区分两者
	4）聚合函数对空值的处理
	聚合函数忽略NULL值
	select avg(comm) from emp
	如果不希望忽略null值，使用NVL函数
	select avg(nvl(comm,0)) from emp
16、GROUP BY 分组
	将结果集按照指定字段进行分组
	分组规则：该字段下的值一样的记录被看做一组
	当希望得到每个部门的平均薪水，而不是整个机构的平均薪水
	select MAX(sal),MIN(sal),AVG(sal),SUM(sal) from emp group by deptno
	select里面如果出现了聚合函数，同时又想出现某一字段时，那么该字段必须出现在group by子句中
	where后面不能使用聚合函数
	select MAX(sal),deptno from emp where MAX(sal)>4000 group by deptno（不能执行）
    HAVING子句
	用来对分组后的结果进一步限制，比如按部门分组后，得到每个部门的最高工资，可以继续限制输出结果
	必须跟在group by后面，不能单独存在
	WHERE是非分组函数的过滤判断
	HAVING是分组（聚合）函数的过滤判断
	查询部门中最大工资超过4000的部门以及最大工资
	select MAX(sal),deptno from emp group by deptno having MAX(sal)>4000
	查看部门编号，以及该部门的平均工资，要求是该部门的平均工资要超过2000，职位是PRESIDENT的不参与统计
	select deptno,AVG(sal) from emp where job <> 'PRESIDENT' group by deptno having AVG(sal)>2000
17、SELECT语句执行过程*****
	1、通过from子句中找到需要查询的表
	2、通过where子句进行非分组函数筛选判断
	3、通过group by子句完成分组操作
	4、通过having子句完成组函数筛选判断
	5、通过select子句选择要显示的列或表达式及组函数
	6、通过order by子句进行排序操作
18、函数总结*****
	单行函数和多行函数的分类并举例说明
	单行函数：
		字符函数：substr() trim() length()...
		数值函数：round() trunc() mod()...
		日期函数：last_day() add_months()...
		转换函数：
			显示转换 to_char() to_date()
			隐式转换 其他类型与字符串连接通常会被转为字符串
		通用函数：NVL() NVL2()
		注意：通常用于操作单行数据 可以任意嵌套多层，多层时由内向外依次执行
	多行函数：MAX()最大值 MIN()最小值 SUM()求和 AVG()平均值 COUNT()统计
19、关联查询
		关联的概念：
			实际应用中所需要的数据，经常会需要查询两个或两个以上的表，这种查询叫做连接查询，连接查询通常建立存在
			相互关
			系的父子表之间
			外键：保存另一张表主键的列称为外键
			含有外键的表，在关联关系中属于多的一方
			表与表之间的关系：一对多（通过外键建立关系），多对多（通过第三张表建立关系），一对一
			N张表的关联查询，最少需要N-1个连接条件，若不指定连接条件，会出现笛卡尔积（无意义的结果集）
		笛卡尔积：
			笛卡尔积指做关联操作的每个表的每一行和其他表的每一行做组合，假设两个表的记录条数分别是X和Y，笛卡尔积将
			返回X*Y条记录
			select count(*) from emp--14条记录
			select count(*) from dept--4条记录
			select * from emp,dept--56条记录
		等值连接 用法：外键=主键
			查看员工名字、工资、部门名称
			select ename,sal,dname from emp e,dept d where e.deptno=d.deptno
			select ename,sal,dname 
			from emp e,dept d 
			where e.deptno=d.deptno and d.loc='CHICAGO'
			KING在哪里工作以及他的部门编号是多少
			select e.ename,e.deptno,d.loc
			from emp e,dept d 
			where e.deptno=d.deptno and e.ename='KING'
			1.可以给表起别名，通过别名指定字段属于哪个表；若两个表字段名称相同，则必须指明数据来源
			2.只有满足连接条件的结果，才会被查询出来
			3.若有过滤条件，需同时满足连接条件和过滤条件的数据才会被查询出来
		内连接：
			返回所有满足连接条件的记录，功能上和等值连接没有区别，只是写法不同
			语法：表1 INNER JOIN 表2 ON 连接条件（INNER可以省略）
			select ename,sal,dname from emp e INNER JOIN dept d ON e.deptno=d.deptno
		外连接
			内连接返回满足连接条件的数据记录，有些情况下需要返回那些不满足连接条件的记录，需要使用外连接
			将满足和不满足连接条件的结果全部查询出来
			快速从已有表中复制数据
			create table empc as select * from emp
			向empc表中插入一条数据 部门号为50
			insert INTO empc(empno,ename,deptno) values(1000,'JACK',50)
			左外连接：(左表的全部，右表的部分)
				根据左表的记录，在被连接的右表中找出符合条件的记录与之匹配，如果找不到与左表匹配的，用null表示
		        语法：表1 LEFT OUTER JOIN 表2 ON 连接条件（OUTER可以省略）
				查询员工的编号，姓名，以及部门名称，包括不属于任何部门的员工
				select empno,ename,dname 
                from empc e 
                left join dept d
                on e.deptno=d.deptno
			右外连接：(右表的全部，左表的部分)
				根据右表的记录，在被连接的左表中找出符合条件的记录与之匹配，如果找不到匹配的，用null补充
				语法：表1 RIGHT OUTER JOIN 表2 ON 连接条件（OUTER可以省略）
				查询员工的编号，姓名，以及部门名称，包括没有员工的部门
				select empno,ename,dname 
                from empc e 
                right join dept d
                on e.deptno=d.deptno
			全外连接
				返回符合条件的所有表的记录，没有与之匹配的，用null表示（结果是左连接和右连接的并集）
				语法：表1 FULL OUTER JOIN 表2 ON 连接条件（OUTER可以省略）
			自连接
				连接的两个表都是同一个表，表中的一个字段可以对应当前表的其它字段
			    查询每个员工的上级领导是谁
				select e.ename emp,m.ename mgr 
				from emp e,emp m 
				where e.mgr=m.empno 
				查询SMITH的上司在哪个城市工作
		Oracle数据库自带语法：*****
			1）笛卡尔积
			2）内连接：1.等值连接
			           2.非等值连接
					   输出员工编号、姓名、工资、工资等级
					   select e.empno,e.ename,e.sal,s.grade 
					   from emp e,salgrade s
					   where e.sal between s.losal and s.hisal
			3）外连接：1.左外连接：
						查询员工的编号，姓名，以及部门名称，包括不属于任何部门的员工
						select empno,ename,dname 
						from emp e,dept d
						where e.deptno=d.deptno(+)
			           2.右外连接：
					   查询员工的编号，姓名，以及部门名称，包括没有员工的部门
						select empno,ename,dname 
						from empc e,dept d
						where e.deptno(+)=d.deptno
		    4）自连接
		通用标准的SQL99语法
			1.交叉连接
				交叉连接和笛卡尔积的连接模式相同，都是表1中的每一行都与表2中的所有行建立一次连接
				select * from emp cross join dept
			2.自然连接
				自然连接第一种情况：能够匹配到等值条件，那么就是等值连接的结果
					select * from emp natural join dept; --根据deptno进行等值连接
				自然连接第二种情况：不能够匹配到等值的条件，那么查询结果就是交叉连接
					select * from emp natural join salgrade; --没有关系交叉连接
			3.左外连接
			4.右外连接
			5.全外连接
				     
20、子查询
	为了给查询提供数据而首先执行的查询语句叫做子查询
	子查询是嵌入在其它SQL语句中的SELECT语句，大部分时候出现在WHERE子句中，子查询嵌入的语句称作主查询或父查询
	子查询需要注意：
		1.子查询需要写在括号中
		2.子查询需要写在运算符的右端
		3.子查询可以写在where,having,from子句中;
		4.子查询中通常不写order by子句
	1）子查询在WHERE子句中
		根据返回结果的不同，子查询分为单行子查询、多行子查询及多列子查询
		1.单行子查询
			返回一行一列数据，单行子查询要求使用单行操作符 > >= < <= <> =
			select ename,sal from emp 
			where sal>(select MAX(sal) 
			from emp where deptno=20)
			查询与SCOTT同部门的员工信息
			select ename,job 
			from emp 
			where deptno=(select deptno from emp where ename='SCOTT')
			查找薪水比整个机构平均薪水高的员工
			select deptno,ename,sal 
			from emp
			where sal>(select avg(sal) from emp)
	    2.多行子查询
			返回多行一列数据，使用多行操作符 in all any
			select * from emp where deptno
			in(select deptno from emp where job='SALESMAN')
			and job <> 'SALESMAN'
			>ANY：比子查询返回结果中的某个值大。即大于最小值
			查询比10号部门某个员工工资高的员工信息
			select empno,ename,sal 
			from emp 
			where sal > any(select sal from emp where deptno=10)
			=ANY：与子查询返回结果中的某个值相等
			查询与10号部门某个员工工资相等的员工信息
			select empno,ename,sal 
			from emp 
			where sal = any(select sal from emp where deptno=10)
			<ANY：比子查询返回结果集中的某个值小
			查询比30号部门某个员工工资少的员工信息
			select empno,ename,sal 
			from emp 
			where sal < any(select sal from emp where deptno=30)  
			>ALL：比子查询返回结果中的所有值都大
			查询比30号部门所有员工工资高的员工信息
			select empno,ename,sal 
			from emp 
			where sal > ALL(select sal from emp where deptno=30)
			<ALL：比子查询返回结果中的所有值都小
			select empno,ename,sal 
			from emp 
			where sal < ALL(select sal from emp where deptno=30)
		3.多列子查询
			通常用于建立在二次查询，常出现在from子句中
			查看低于自己所在部门平均工资的员工
			1.分组统计部门平均工资
			select avg(sal) aa,deptno from emp group by deptno
			2.员工工资<所在部门平均工资
			select sal,ename,e.deptno 
			from emp e,(select avg(sal) aa,deptno from emp group by deptno) t
			where e.deptno=t.deptno and sal<aa
	    4.EXISTS关键字
			在子查询中需要引用到主查询的字段数据，使用EXISTS关键字
			EXISTS后边的子查询至少返回一行数据，则整个条件返回true
			列出来那些有员工的部门信息
			select deptno,dname from dept d where EXISTS
			(select * from emp e where d.deptno=e.deptno)
	2）子查询在HAVING子句中
		查询最低工资高于部门30的最低工资的部门信息
		select deptno,min(sal) 
		from emp 
		group by deptno 
		having min(sal)>(select min(sal) from emp where deptno=30)
	3）子查询在select部分
		外连接的另一种写法，不推荐
		查询每一个员工的同时，根据员工的部门编号查询部门的名称，若查询不到部门，该员工的部门信息就是null
		select e.ename,e.sal,
		(select d.dname from dept d where d.deptno=e.deptno) dname
		from empc e 
20、分页查询
	找到员工表中工资最高的前三名（降序排序）
	select * from emp order by sal desc
	select rownum,e.* from emp e order by sal desc
	--将上面的结果当作一张表处理，再查询
	select rownum,t1.* from (select e.* from emp e order by sal desc) t1
	--只要显示前三条记录
	select rownum,t1.* from (select e.* from emp e order by sal desc) t1 where rownum<4
	ROWNUM:伪列，系统自动生成的一列，用来表示行号
	rownum是ORACLE中特有的用来表示行号，默认值或起始值是1，在查询出结果之后，再加1
	查询rownum大于2的所有记录
	select rownum,e.* from emp e where rownum>2--没有任何记录
	查询rownum大于等于1的所有记录
	select rownum,e.* from emp e where rownum>=1
	查询rownum小于6的所有记录
	select rownum,e.* from emp e where rownum<6
	查询第6~第10条记录
	第一种：
	select * from (select rownum rn,e.* from emp e) t
	where t.rn between 6 and 10
	第二种：
	select t1.* from (select emp.*,rownum rn from emp where rownum <=10) t1 where rn >=6;
	在oracle中只能使用子查询来做分页查询
	页码：page
	每页最多条数：pageSize 5条
	第一页：1~5
	第二页：6~10
	第三页：11~15
	start：(page-1)*pageSize+1
	end：pageSize*page
21、DECODE函数
	DECODE(参数1,值1,结果1,值2,结果2...[,默认值])
	参数1依次与值进行匹配，与哪个匹配成功则显示对应的结果，若均未匹配，则显示最后一个默认值
	查询职员表，根据职员的职位计算奖励金额，当职位分别是'MANAGER','SALESMAN','ANALYST'时，
	奖励金分别是薪水的1.2倍，1.1倍，1.05倍，如果不是这三个职位，则奖励金额取薪水值
	select ename,job,sal,
	decode(job,
		'MANAGER',sal*1.2
		'SALESMAN',sal*1.1
		'ANALYST',sal*1.05
		sal
	) "奖金" from emp
	分组操作：
	select decode(job,
	'MANAGER','VIP',
	'ANALYST','VIP',
	'OPERATION'
	) from emp group by 
	decode(job,
	'MANAGER','VIP',
	'ANALYST','VIP',
	'OPERATION'
	)
	排序：
	select * from emp order by decode(job,
		'MANAGER',1
		'SALESMAN',2
		'ANALYST',3
		4
	)
22、集合函数
	UNION并集：将两个查询结果进行排序
		所有的查询结果可能不是来自同一张表
		
		工资大于1500，或者20号部门下的员工
		select * from emp where sal>1500 or deptno=20
		--工资大于1500，或者20号部门下的员工
		select * from emp where sal>1500
		--20号部门下的员工
		select * from emp where deptno=20
		并集运算：union、union all
		union：去除重复的，并且排序
		union all：不会去除重复的
			select * from emp where sal>1500
			union
			select * from emp where deptno=20
	INTERSECT交集：同时存在于两个结果集中的数据
		工资大于1500并且在20号部门下的员工
			select * from emp where sal>1500
			INTERSECT
			select * from emp where deptno=20
	MINUS差集：两个结果相减
		1981年入职员工（不包括总裁和经理）
		--1981年入职员工
		select * from emp where to_char(hiredate,'YYYY')='1981'
		--总裁和经理
		select * from emp where where job='PRESIDENT' or job='MANAGER'
		
		select * from emp where to_char(hiredate,'YYYY')='1981'
		MINUS
		select * from emp where job='PRESIDENT' or job='MANAGER
	集合运算中的注意事项：
	1.列的类型要一致
	2.按照顺序写
	3.列的数量要一致，如果不足，用空值填充
	--列的类型不匹配
	select ename,sal from emp where sal>1500
	union
	select sal,ename from emp where deptno=20
	--列的数量不匹配
	select ename,sal,deptno from emp where sal>1500
	union
	select ename,sal from emp where deptno=20
23、DDL语句管理表
	1）创建表空间：
		逻辑单位，通常我们新建一个项目，就会新创建表空间，在表空间中创建用户来创建表
	语法：
		create tablespace 表空间的名称
		datafile '文件的路径'
		size 大小
		autoextend on 自动扩展
		next 每次扩展的大小
	切换到system账号下创建
	删除表空间：
		drop tablespace YYP
	2）创建用户：
		create user 用户名 
		identified by 密码 
		default tablespace 表空间的名称
	删除用户
		drop user yuanyipeng cascade;
	更改用户密码
		alter user 用户名 identified by 密码;
	授权
		grant connect to yuanyipeng
	分配角色
		grant dba to yuanyipeng
		select * from scott.emp
	使用子查询的方式创建表：
		create table 表名 as 查询语句
		create table emp as select * from scott.emp
	注意：只会复制表结构和表中数据，不会复制列的约束
		  如果查询语句有结果，就是复制表结构和数据
		  如果查询语句没有结果，就是复制表结构
    只复制表数据（添加语句里可以没有values关键字）
		insert into 表名 查询语句（表的结构与已有表结构一致）
	3）列的约束：约束主要是用来约束表中数据的规则
		主键约束：primary key 不能为空，必须唯一
		非空约束：not null
		唯一约束：unique
		检查约束：check(条件)在mysql中是可以写的，但是mysql直接忽略了检查约束
		外键约束：主要是用来约束从表A中的记录，必须是存在于主表B中(保证数据完整性)
		create table books(
			book_id number(10) primary key,
			book_name varchar2(20) not null,
			price number(10,2),
			cid number(10) not null references category(id)--外键约束
		);
		create table books(
			book_id number(10) primary key,
			book_name varchar2(20) not null,
			price number(10,2),
			cid number(10) not null,
			foreign key(cid) references category(id)--外键约束
		);
		
		create table category(
			id number(10) primary key,
			cname varchar2(10)
		);
		alter table books add foreign key(cid) references category(id)
24、视图
	数据库对象之一，视图在sql语句中体现的角色和表完全相同，但是视图并不是一个真实存在的表，它对应的是一
	个查询语句的结果集（视图名跟表名不能一样）
	视图的作用：简化复杂查询、限制数据访问
	1）创建简单视图（单表）
	若无权限，使用system用户授权
	视图授权语句：
	grant create view to 用户名;
	创建一个简单视图v_emp_10来显示部门10中的员工的编码、姓名和薪水
	create view v_emp_10
	as 
	select empno,ename,sal,deptno
	from emp where deptno=10;
	2）修改视图
	修改视图就是替换该视图的子查询，使用create or replace view 视图名即可，若视图不存在就创建，存在就替换
	创建视图时，给列赋予别名
	create or replace view v_emp_10
	as 
	select empno id,ename name,sal salary,deptno
	from emp where deptno=10;
	3）查询视图
	select * from v_emp_10
	视图的列名和创建视图时的列名一致，不一定是原列名;
	select id,name,salary from v_emp_10
	4）视图的DML操作
	对视图进行DML操作就是对视图数据来源的基础表进行操作
	插入数据：
		1.注意视图中看不见的字段都被插入默认值，所以不能违反基础表中相应字段的约束条件，尤其是看不见的
		字段的not null，否则会插入失败
		2.为视图添加检查选项可以避免对视图进行DML操作时污染基础表，在创建语句后加with check option
		3.如果没有在视图上执行DML操作的必要，在建立视图时声明为只读来避免这种情况，保证视图对应的基础表
		数据不会被非法修改with read only
	5）视图根据子查询的不同，分为简单视图和复杂视图，当子查询中包含单行函数、表达式或分组函数时，该视图是
	一个复杂视图，复杂视图不能进行DML操作，必须为子查询中的表达式或函数定义别名
	创建一个视图v_emp_salary，把职员表的数据按部门分组，获得每个部门的平均薪水、薪水总和、最低薪水
	create view v_emp_salary
	as
	select d.dname,avg(sal) avg_sal,sum(sal) sum_sal,min(sal) min_sal from emp e,dept d
	where e.deptno=d.deptno group by d.dname
	6）删除视图
	DROP VIEW 视图名称
25、序列：sequence 用来生成唯一数字值的数据库对象，通常作为表的主键值
		序列是独立的数据库对象，序列并不依附于表
	1）创建序列
	create sequence 序列名
	start with xx 起始数据
	increment by xx 步长（每次增加几）
	maxvalue xx 最大值
	minvalue xx 最小值
	
	create sequence users_seq
	start with 100
	increment by 10
	
	序列中有两个伪列
	---nextval：获取序列的下个值
	---currval: 获取序列的当前值
	当序列创建以后，必须先执行一次nextval，之后才能使用currval
	获取序列的第一个值，并且使用序列值为users表插入新的记录
	select users_seq.nextval from dual;
	insert into users(id,name) values(users_seq.nextval,'马冬梅')
	2）删除序列：drop sequence users_seq
26、索引：一种提高查询效率的机制
	经常作为过滤条件，去重，排序或链接条件的字段可以为其添加索引
	1）创建索引：
	create [unique] index 索引名称
	on 表名(列名)
	添加单列索引
	在users表的name列上建立索引
	create index idx_users_name on users(name);
	添加多列索引
	create index idx_users_name_salary on users(name,salary);
	查询过程中自动应用索引，不需要我们制定，提高查询速度
	select * from users order by name,salary
	2）修改或删除索引
	如果经常在索引列上执行DML操作，需要定期重建索引，提高索引的空间利用率
	alter index 索引名称 rebuild
	删除索引：drop index 索引名称	  